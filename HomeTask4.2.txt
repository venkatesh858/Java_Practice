/*
 * Home Task 4.2
 * Program 1:
 * 
 * Consider the leftmost and righmost appearances of some value in an array. 
 * We'll say that the "span" is the number of elements between the two inclusive. A single value has a span of 1. 
 * Returns the largest span found in the given array. (Efficiency is not a priority.)
 */

package task.loopsarrays;

public class CalculateMaxSpan {

	public int maxSpan(int[] numbers) {
		int max = 0;

		for (int index = 0; index < numbers.length; index++) {
			int i = numbers.length - 1;

			while (numbers[index] != numbers[i])
				i--;
			int span = i - index + 1;

			if (span > max)
				max = span;
		}
		return max;
	}

	public static void main(String[] args) {
		CalculateMaxSpan c = new CalculateMaxSpan();

		System.out.println(" Max Span is:" + c.maxSpan(new int[] { 1, 2, 1, 1, 3 }));
		System.out.println(" Max Span is:" + c.maxSpan(new int[] { 1, 4, 2, 1, 4, 1, 4 }));
		System.out.println(" Max Span is:" + c.maxSpan(new int[] { 1, 4, 2, 1, 4, 4, 4 }));
		System.out.println(" Max Span is:" + c.maxSpan(new int[] { 1, 2, 3 }));
	}
}
--------------------------------------------------------------------------------------------------------
/*
 * Home Task 4.2
 * Program 2:
 * 
 * Given a non-empty array, return true if there is a place to split the array 
 * so that the sum of the numbers on one side is equal to the sum of the numbers on the other side.
 */

package task.loopsarrays;

public class SplitArray {
	public boolean canBalance(int[] nums) {
		int first = 0;
		int second = 0;

		for (int i = 0; i < nums.length; i++)
			second += nums[i];

		for (int i = 0; i <= nums.length - 2; i++) {
			first += nums[i];
			second -= nums[i];

			if (first == second)
				return true;
		}

		return false;
	}

	public static void main(String[] args) {

		SplitArray sa = new SplitArray();
		System.out.println(sa.canBalance(new int[] { 1, 2, 3, 4, 5, 3, 2, 4, 1 }));
		System.out.println(sa.canBalance(new int[] { 1, 1, 1, 2, 1 }));
		System.out.println(sa.canBalance(new int[] { 2, 1, 1, 2, 1 }));
		System.out.println(sa.canBalance(new int[] { 10, 10 }));

	}

}
--------------------------------------------------------------------------------------------------------
/*
 * Home Task 4.2
 * Program 3:
 * 
 * Say that a "clump" in an array is a series of 2 or more adjacent elements of the same value. 
 * Return the number of clumps in the given array.
 */
package task.loopsarrays;

public class CalculateClumps {

	public int countClumps(int[] nums) {
		int count = 0;
		int i = 0;
		while (i < nums.length) {
			int val = nums[i];
			i++;
			int length = 1;
			while (i < nums.length && nums[i] == val) {
				i++;
				length++;
			}
			if (length > 1)
				count++;
		}
		return count;
	}

	public static void main(String[] args) {
		CalculateClumps cc = new CalculateClumps();
		System.out.println("No. of clumns: "+ cc.countClumps(new int[] { 1, 2, 2, 3, 4, 4 }));
		System.out.println("No. of clumns: "+ cc.countClumps(new int[] { 1, 1, 2, 1, 1 }));
		System.out.println("No. of clumns: "+ cc.countClumps(new int[] { 1, 1, 1, 1, 1 }));

	}
}
--------------------------------------------------------------------------------------------------------
/*
 * Home Task 4.2
 * Program 4:
 * 
 * We'll say that a "mirror" section in an array is a group of contiguous elements such that somewhere in the array, 
 * the same group appears in reverse order. 
 * For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). 
 * Return the size of the largest mirror section found in the given array.
 */
package task.loopsarrays;

public class CalculateMaxMirror {

	public int maxMirror(int[] nums) {
		int max = 0;

		for (int i = 0; i < nums.length; i++) {
			int count = 0;
			for (int j = nums.length - 1; j >= 0 && i + count < nums.length; j--) {
				if (nums[i + count] == nums[j]) {
					count++;
				} else {
					max = Math.max(max, count);
					count = 0;
				}
			}
			max = Math.max(max, count);
		}
		return max;
	}

	public static void main(String[] args) {
		
		

	}
}
--------------------------------------------------------------------------------------------------------
/* 
 * Home Taks 4.2
 * Program 5:
 * 
 * Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. 
 * The best solution makes only a single "linear" pass of both arrays, taking advantage of the fact that both arrays are already 
 * in sorted order. 
 */

package task.loopsarrays;

public class CompareArrays {

	public boolean linearIn(int[] outer, int[] inner) {
		  
	    int i = 0;
	    int j = 0;
	      
	    while(i < inner.length && j < outer.length) {
	        if(inner[i] > outer[j]) {
	            j++;
	        } else if(inner[i] < outer[j]) {
	            return false;
	        } else {
	            i++;
	        }
	    }
	    if(i != inner.length)
	        return false;
	    return true;
	}

	public static void main(String[] args) {
		CompareArrays ca=new CompareArrays();
		System.out.println(ca.linearIn(new int[] {1,2,3}, new int[] {2,4,5}));
	}
}
